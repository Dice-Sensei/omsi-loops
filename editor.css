:root {
    --absence-text: "absent";
}

ul + .button {
    margin-top:4px;
}

.elementList {
    padding-left: 1em;
}

.elementList > li {
    list-style-type: none;
}

.elementList > li > details > summary {
    font-weight: bold;
    font-size: larger;
}

.elementList > li > details > fieldset {
    margin-bottom: 1lh;
}

summary {
    cursor: pointer;
}

fieldset > * {
    display: block;
    margin: 0.25lh 0 0;
}

.fieldrow {
    display: flex;
    flex-wrap: wrap;
    gap: 1em;
    align-content: stretch;
    justify-content: stretch;
}

.fieldrow > label {
    flex: 1 0 min-content;
    display: flex;
    align-items: baseline;
    white-space: nowrap;
    gap: 0.5em;
}

.fieldrow > label > * {
    flex: 1 0 min-content;
}

.actionDefinition:not([data-action-type="normal"]) .normalOnly,
.actionDefinition:not([data-action-type="limited"]) .limitedOnly,
.actionDefinition:not([data-action-type="progress"]) .progressOnly,
.actionDefinition:not([data-action-type="multipart"]) .multipartOnly
{
    display: none;
}

.numericEvaluation > details > summary > [value] ~ .baseValueCalculation {
    display: none;
}

.optional > details > summary:has(>label>input.elementPresent:not(:checked)) {
    list-style-type: disc;
    color: color-mix(in srgb, currentColor, transparent 50%);
    &:not(details[open]>summary) {
        pointer-events: none;
    }
    &>label {
        pointer-events: auto;
    }
    &>label ~ * {
        display:none;
    }
    &::after {
        content: " (" var(--absence-text) ")";
    }
}

ul.evaluationRules {
    padding-left: 2em;
}

li.evaluationRule {
    list-style: none;
}

.evaluationRule > details > summary {
    list-style-position: outside;
    margin-left: 1em;
}

details:not([open]) > summary:has( ~ .evaluationRules > .evaluationRule)::after {
    content: "(...)";
}

.conditionalEvaluation > details > .evaluationRules > .evaluationRule > details > summary > .evaluationRuleType > optgroup[label=Adjustments] {
    display: none;
}

details.baseValueCalculation {
    display: inline-block;
}
details.baseValueCalculation > summary {
    list-style: none;
}

.evaluationRule > details > summary > select.evaluationRuleType ~ *,
details.baseValueCalculation > summary > select.baseValueType ~ * {
    display: none;
}
:is(.evaluationRule.skillName > details, details.skillName) > summary > shrink-wrap[name=skillName],
:is(.evaluationRule.buffName > details, details.buffName) > summary > shrink-wrap[name=buffName],
:is(.evaluationRule.actionName > details, details.actionName) > summary > shrink-wrap[name=actionName],
:is(.evaluationRule.functionName > details, details.functionName) > summary > shrink-wrap[name=functionName],
:is(.evaluationRule.varName > details, details.varName) > summary > shrink-wrap[name=varName],
.evaluationRule.adjustmentName > details > summary > shrink-wrap[name=adjustmentName],
.evaluationRule.prestigeBuffName > details > summary > shrink-wrap[name=prestigeBuffName],
.evaluationRule.varName > details > summary > shrink-wrap[name=varName] {
    display: revert;
}

.evaluationRule.numericCondition > details > summary > .numericTestType.numericTest1 {
    display: revert;
    &[value] ~ .numericTestValue.numericTest1 {
        display: revert;
    }
    &[value] ~ span.numericTestType.numericTest2:has(+.numericTest2[value]) {
        display: revert;
    }
    &[value] ~ shrink-wrap.numericTestType.numericTest2 {
        display: revert;
        &[value] ~ .numericTestValue.numericTest2 {
            display: revert;
        }
    }
}

.evaluationRule.numericEvaluation > details > summary > [name=value] {
    display: revert;
}

.evaluationRule.skillMod > details > summary > :is(.numericTestType, .numericTestValue) {
    display: revert;
}
.evaluationRule.skillMod > details > summary > .skillModOnly {
    display: revert;
}
.evaluationRule.skillMod > details > summary > select[name=numericTest1] > option:not([value=minExclusive]),
.evaluationRule.skillMod > details > summary > select[name=numericTest2] > option:not([value=max]){
    display: none;
}

.shrink-wrapped.label {
    display: inline-block;
    min-width: 1ch;
    min-height: 1lh;
    padding: 1px;
    border: 1px dashed currentColor;
    margin: 1px 0
}

shrink-wrap:focus-within > .label {
    margin: 1px 2px;
}

.addRule {
    margin-left: 2em;
}
.addRule::after {
    content: "Add adjustment/condition";
}
.evaluationRule:not(.numericEvaluation) > details > .addRule::after,
.conditionalEvaluation > details > .addRule::after {
    content: "Add condition";
}